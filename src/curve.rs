use std::ops::{Add, Mul};

use bevy::math::*;
use bevy::prelude::{Mesh, Vec3};

use itertools::Itertools;

pub trait Curve {
    fn p(&self, u: f32) -> Vec3;
    fn dp(&self, u: f32) -> Vec3;
    fn d2p(&self, u: f32) -> Vec3;

    fn tangent(&self, u: f32) -> Vec3 {
        self.dp(u).normalize()
    }

    fn normal(&self, u: f32) -> Vec3 {
        let dpdu = self.dp(u);
        let d2pdu2 = self.d2p(u);

        dpdu.cross(d2pdu2.cross(dpdu)).normalize()
    }

    fn binormal(&self, u: f32) -> Vec3 {
        self.dp(u).cross(self.d2p(u)).normalize()
    }

    fn frame(&self, u: f32) -> Affine3A {
        Affine3A::from_mat3_translation(
            Mat3::from_cols(self.binormal(u), self.normal(u), self.tangent(u)),
            self.p(u),
        )
    }

    fn equidistant_resampling(&self, u_start: f32, u_stop: f32, ds: f32) -> Vec<f32> {
        let mut u = u_start;
        let mut us = Vec::<f32>::new();
        while u < u_stop {
            us.push(u);
            let dpdu = self.dp(u);
            // let d2pdu2 = self.d2p(u);
            // u += ds * dpdu.length_recip() - ds * ds / 4. * dpdu.dot(d2pdu2) / dpdu.length_squared();
            u += ds * dpdu.length_recip();
        }

        us
    }

    fn ribbon_mesh(&self, u_start: f32, u_end: f32, ds: f32, width: f32) -> Mesh {
        let us = self.equidistant_resampling(u_start, u_end, ds);
        // us.resize(2, 0.);
        let ps = us.iter().map(|&u| self.p(u));
        let xs = us.iter().map(|&u| self.binormal(u));

        let mut verts: Vec<[f32; 3]> = Vec::with_capacity(us.len() * 2);
        let mut normals = verts.clone();
        let uvs: Vec<[f32; 2]> = (0..verts.capacity())
            .map(|i| [(i % 2) as f32, ((i / 2) % 2) as f32])
            .collect();

        let w2 = width / 2.;
        for (p, x) in ps.zip(xs) {
            verts.push((p - w2 * x).to_array());
            verts.push((p + w2 * x).to_array());
        }

        for &u in us.iter() {
            let n = (-self.normal(u)).to_array();
            normals.push(n);
            normals.push(n);
        }

        println!("{:#?}", verts);

        let mut indices = (0..verts.len() as u32).collect::<Vec<_>>();
        let mut reversed: Vec<_> = indices.clone().into_iter().rev().skip(1).collect();
        indices.append(&mut reversed);

        println!("{:#?}", indices);

        let mut mesh = Mesh::new(bevy::render::render_resource::PrimitiveTopology::TriangleStrip);
        mesh.set_attribute(
            Mesh::ATTRIBUTE_COLOR,
            verts
                .iter()
                .map(|_| [0.0, 0.0, 0.0, 1.0])
                .collect::<Vec<[f32; 4]>>(),
        );

        mesh.set_attribute(Mesh::ATTRIBUTE_POSITION, verts);
        mesh.set_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
        mesh.set_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
        mesh.set_indices(Some(bevy::render::mesh::Indices::U32(indices)));
        mesh
    }
}

const fn catmull_rom_matrix(tau: f32) -> Mat4 {
    const_mat4!(
        // [0., -tau, 2. * tau, -tau],
        // [1., 0., tau - 3., 2. - tau],
        // [0., tau, 3. - 2. * tau, tau - 2.],
        // [0., 0., -tau, tau]
        [0., 1., 0., 0.],
        [-tau, 0., tau, 0.],
        [2. * tau, tau - 3., 3. - 2. * tau, -tau],
        [-tau, 2. - tau, tau - 2., tau]
    )
}

const TAU: f32 = 0.5;

pub struct CatmullRom3 {
    pub pts: Vec<Vec3>,
    pub coefs: Vec<Mat4>,
}

impl CatmullRom3 {
    pub fn new(pts: Vec<Vec3>) -> Self {
        let coefs = pts
            .iter()
            .map(|pt| pt.extend(0.))
            .tuple_windows()
            .map(|(p0, p1, p2, p3)| {
                Mat4::from_cols(p0, p1, p2, p3).mul_mat4(&catmull_rom_matrix(TAU))
            })
            .collect();

        Self { pts, coefs }
    }

    fn normalize(&self, mut u: f32) -> (f32, usize) {
        u *= self.coefs.len() as f32;
        let i = u.floor().clamp(0., self.coefs.len() as f32 - 1.);

        (u - i, i as usize)
    }
}

impl Curve for CatmullRom3 {
    fn p(&self, u: f32) -> Vec3 {
        let (u, i) = self.normalize(u);
        self.coefs[i]
            .mul_vec4(const_vec4!([1., u, u * u, u * u * u]))
            .truncate()
    }

    fn dp(&self, u: f32) -> Vec3 {
        let (u, i) = self.normalize(u);
        self.coefs[i]
            .mul_vec4(const_vec4!([0., 1., 2. * u, 3. * u * u]))
            .truncate()
            * self.coefs.len() as f32
    }

    fn d2p(&self, u: f32) -> Vec3 {
        let (u, i) = self.normalize(u);
        self.coefs[i]
            .mul_vec4(const_vec4!([0., 0., 2., 6. * u]))
            .truncate()
            * self.coefs.len().pow(2) as f32
    }
}

// Generates the basis for the one-parameter family of solutions to AiA* = c.
// This function returns the quaternions A1, A2 such that any solution
// to AiA* = c can be generated by the solution A1 cos t + A2 sin t.
fn inverse_solve_quat(c: Vec3) -> (Quat, Quat) {
    let [lambda, mu, nu] = c.normalize().to_array();
    let r = 0.5 * (1. + lambda) * c.length();
    (
        quat(1., mu / (1. + lambda), nu / (1. + lambda), 0.) * r,
        quat(0., nu / (1. + lambda), -mu / (1. + lambda), -1.) * r,
    )
}

fn quat_cross_term_basis(c0: Vec3, c1: Vec3) -> (Vec3, Vec3) {
    let [l0, mu0, nu0] = c0.normalize().to_array();
    let [l1, mu1, nu1] = c1.normalize().to_array();

    let (l0p, l1p) = (1. + l0, 1. + l1);
    let r = (l0p * l1p).sqrt();

    (
        vec3(
            l0p * l1p - (mu0 * mu1 + nu0 * nu1),
            l1p * mu0 + l0p * mu1,
            l1p * nu0 + l0p * nu1,
        ) / r,
        vec3(
            mu0 * nu1 - mu1 * nu0,
            l0p * nu1 - l1p * nu0,
            l1p * mu0 - l0p * mu1,
        ) / r,
    )
}

fn hermite_quintic_polynomial<T: Copy + Add<Output = T> + Mul<f32, Output = T>>(
    coefs: [T; 5],
    t: f32,
) -> T {
    coefs[0] * (1. - t).powi(4)
        + coefs[1] * (1. - t).powi(3) * t * 4.
        + coefs[2] * ((1. - t) * t).powi(2) * 6.
        + coefs[3] * (1. - t) * t.powi(3) * 4.
        + coefs[4] * t.powi(4)
}

fn hermite_quintic_polynomial_integral<T: Copy + Add<Output = T> + Mul<f32, Output = T>>(
    coefs: [T; 5],
    t: f32,
) -> T {
    coefs[0] * 0.2 * (t - 1.).powi(5)
        + coefs[1] * (-0.2 * (t - 1.).powi(5) - 0.25 * (t - 1.).powi(4) + 0.05)
        + coefs[2] * (0.2 * t.powi(5) - 0.5 * t.powi(4) + t.powi(3) / 3.)
        + coefs[3] * (0.25 * t.powi(4) - 0.2 * t.powi(5))
        + coefs[4] * 0.2 * t.powi(5)
}

fn hermite_quintic_polynomial_derivative<T: Copy + Add<Output = T> + Mul<f32, Output = T>>(
    coefs: [T; 5],
    t: f32,
) -> T {
    coefs[0] * -4. * (1. - t).powi(3)
        + coefs[1] * (1. - 4. * t) * (1. - t).powi(2)
        + coefs[2] * 2. * (t - 1.) * t * (2. * t - 1.)
        + coefs[3] * (3. - 4. * t) * t.powi(2)
        + coefs[4] * 4. * t.powi(3)
}

#[derive(Debug, Clone)]
pub struct HermiteQuintic {
    p0: Vec3,
    _p1: Vec3,
    weights: [f32; 5],
    weighted_tangents: [Vec3; 5],
}

impl HermiteQuintic {
    pub fn tangent(&self, u: f32) -> Vec3 {
        hermite_quintic_polynomial(self.weighted_tangents, u)
            / hermite_quintic_polynomial(self.weights, u)
    }

    fn curvature_squared(&self, u: f32) -> f32 {
        self.dp(u).cross(self.d2p(u)).length_squared()
            / hermite_quintic_polynomial(self.weights, u).powi(6)
    }

    pub fn speed(&self, u: f32) -> f32 {
        hermite_quintic_polynomial(self.weights, u)
    }

    pub fn p(&self, u: f32) -> Vec3 {
        self.p0 + hermite_quintic_polynomial_integral(self.weighted_tangents, u)
            - hermite_quintic_polynomial_integral(self.weighted_tangents, 0.)
    }

    pub fn dp(&self, u: f32) -> Vec3 {
        hermite_quintic_polynomial(self.weighted_tangents, u)
    }

    pub fn d2p(&self, u: f32) -> Vec3 {
        hermite_quintic_polynomial_derivative(self.weighted_tangents, u)
    }

    pub fn elastic_bending_energy(&self) -> f32 {
        (0..100)
            .map(|x| x as f32 * 0.01)
            .map(|u| self.curvature_squared(u) * self.speed(u) * 0.01)
            .sum()
    }

    pub fn new(pi: Vec3, pf: Vec3, di: Vec3, df: Vec3) -> HermiteQuintic {
        let (u, v) = quat_cross_term_basis(di, df);
        let h = 120. * (pf - pi) - 15. * (di + df);

        let d4 = h.cross(df).dot(u) * di.cross(h).dot(u) - di.cross(df).dot(h - 5. * u).powi(2);
        let d3 = -2. * h.cross(df).dot(u) * di.cross(h).dot(v)
            - 2. * di.cross(h).dot(u) * h.cross(df).dot(v)
            - 20. * di.cross(df).dot(v) * di.cross(df).dot(h - 5. * u);
        let d2 = -2. * h.cross(df).dot(u) * di.cross(h).dot(u)
            + 4. * h.cross(df).dot(v) * di.cross(h).dot(v)
            - 100. * di.cross(df).dot(v).powi(2)
            - 2. * di.cross(df).dot(h - 5. * u) * di.cross(df).dot(h + 5. * u);
        let d1 = 2. * h.cross(df).dot(v) * di.cross(h).dot(u)
            + 2. * di.cross(h).dot(v) * h.cross(df).dot(u)
            - 20. * di.cross(df).dot(v) * di.cross(df).dot(h + 5. * u);
        let d0 = h.cross(df).dot(u) * di.cross(h).dot(u) - di.cross(df).dot(h + 5. * u).powi(2);

        let roots = roots::find_roots_quartic(d4, d3, d2, d1, d0);

        roots
            .as_ref()
            .iter()
            .flat_map(|&t| {
                let cos = (1. - t.powi(2)) / (1. + t.powi(2));
                let sin = 2. * t / (1. + t.powi(2));
                let n = u * cos + v * sin;

                println!("{}, {}", df, di);
                println!("{}", n);

                let _16k0sq = h.cross(df).dot(n) / di.cross(df).dot(n);
                let _16k2sq = di.cross(h).dot(n) / di.cross(df).dot(n);

                println!("{}, {}", _16k0sq, _16k2sq);

                if _16k0sq > 0. && _16k2sq > 0. {
                    Some((t, 0.25 * _16k0sq.sqrt(), 0.25 * _16k2sq.sqrt()))
                } else {
                    None
                }
            })
            .flat_map(|(t, k0, k2)| [(t, -k0, k2), (t, k0, -k2)])
            .map(|(t, k0, k2)| (2. * t.atan(), k0 - 0.75, k2 - 0.75))
            .map(|(phi, c0, c2)| {
                let phi0 = 0.;
                let phi1 = phi0 + phi;

                let (x0, y0) = inverse_solve_quat(di);
                let (x2, y2) = inverse_solve_quat(df);

                let a0 = x0 * phi0.cos() + y0 * phi0.sin();
                let a2 = x2 * phi1.cos() + y2 * phi1.sin();

                ((c0, c2), (a0, a2))
            })
            .map(|((c0, c2), (a0, a2))| {
                let a0len2 = a0.length_squared();
                let a2len2 = a2.length_squared();
                let a0a2 = a0.w * a2.w - a0.xyz().dot(a2.xyz());

                let w0 = a0len2;
                let w1 = c0 * a0len2 + 0.5 * c2 * a0a2;
                let w2 = (1. / 6.)
                    * (4. * c0.powi(2) * a0len2
                        + (1. + 4. * c0 * c2) * a0a2
                        + 4. * c2.powi(2) * a2len2);
                let w3 = 0.5 * a0a2 + c2 * a2len2;
                let w4 = a2len2;

                const I: Quat = const_quat!([1., 0., 0., 0.]);

                let a0ia0 = a0.mul_vec3(Vec3::X);
                let a2ia2 = a2.mul_vec3(Vec3::X);
                let a0ia2 = (a0 * I * a2.conjugate() + a2 * I * a0.conjugate()).xyz();

                let wt0 = a0ia0;
                let wt1 = c0 * a0ia0 + 0.5 * c2 * a0ia2;
                let wt2 = (1. / 6.)
                    * (4. * c0.powi(2) * a0ia0
                        + (1. + 4. * c0 * c2) * a0ia2
                        + 4. * c2.powi(2) * a2ia2);
                let wt3 = 0.5 * c0 * a0ia2 + c2 * a2ia2;
                let wt4 = a2ia2;
                HermiteQuintic {
                    p0: pi,
                    _p1: pf,
                    weights: [w0, w1, w2, w3, w4],
                    weighted_tangents: [wt0, wt1, wt2, wt3, wt4],
                }
            })
            .max_by_key(|h| ordered_float::OrderedFloat(h.elastic_bending_energy()))
            .unwrap()

        // let (ax0, ay0) = inverse_solve_quat(d0);
        // let (ax1, ay1) = inverse_solve_quat(d1);
    }
}

impl Curve for HermiteQuintic {
    fn p(&self, u: f32) -> Vec3 {
        self.p(u)
    }

    fn dp(&self, u: f32) -> Vec3 {
        self.dp(u)
    }

    fn d2p(&self, u: f32) -> Vec3 {
        self.d2p(u)
    }
}
